package com.bc.calvalus.reporting.code;import com.bc.calvalus.commons.CalvalusLogger;import com.bc.calvalus.reporting.common.Report;import com.bc.calvalus.reporting.common.Reporter;import com.bc.calvalus.reporting.common.ReportingConnection;import com.bc.calvalus.reporting.common.StatusHandler;import java.io.FileReader;import java.io.IOException;import java.io.Reader;import java.util.Properties;import java.util.concurrent.ScheduledExecutorService;import java.util.concurrent.ScheduledThreadPoolExecutor;import java.util.logging.Level;import java.util.logging.Logger;/** * @author Hans Permana */public class CodeReporting implements Reporter {    private static final Logger LOGGER = CalvalusLogger.getLogger();    private final Properties config;    private final AccountingJmsConnection accountingJmsConnection;    private final ReportingConnection reportingConnection;    private final StatusHandler statusHandler;    private ScheduledExecutorService executorService;    private CodeReporting(String configPath) throws IOException {        config = loadConfiguration(configPath);        accountingJmsConnection = new AccountingJmsConnection(this);        reportingConnection = new ReportingConnection(this);        statusHandler = new StatusHandler(this);        executorService = new ScheduledThreadPoolExecutor(1);        statusHandler.initReport();        reportingConnection.pollReportingServer();        accountingJmsConnection.close();    }    public static void main(String[] args) {        try {            new CodeReporting(args.length > 0 ? args[0] : "etc/code.properties");        } catch (IOException e) {            LOGGER.severe("CodeReporting start failed: " + e.getMessage());            System.exit(1);        }    }    @Override    public String getName() {        return "code";    }    @Override    public Properties getConfig() {        return config;    }    @Override    public void process(Report report) {        switch (report.state) {        case NOT_YET_RETRIEVED:            getStatusHandler().setRunning(report.job, report.creationTime);            // fall through, no break        case NEW:            reportingConnection.retrieveSingle(report);            break;        case NOT_YET_ACCOUNTED:            getStatusHandler().setRunning(report.job, report.creationTime);            // fall through, no break        case RETRIEVED:            try {                accountingJmsConnection.send(report);            } catch (Exception exception) {                LOGGER.log(Level.SEVERE, "Unable to send the report", exception);            }            break;        default:            LOGGER.warning("report " + report.job + " in state " + report.state + " cannot be handled");        }    }    @Override    public StatusHandler getStatusHandler() {        return statusHandler;    }    @Override    public ScheduledExecutorService getExecutorService() {        return executorService;    }    @Override    public void setExecutorService(ScheduledExecutorService executorService) {        this.executorService = executorService;    }    private static Properties loadConfiguration(String configPath) throws IOException {        try {            Properties config = new Properties();            try (Reader in = new FileReader(configPath)) {                config.load(in);            }            return config;        } catch (IOException e) {            throw new IOException("failed to read configuration from " + configPath + ": " + e.getMessage(), e);        }    }}